package com.draper.cage.taint;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.AbstractMap;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.Map;

import soot.G;
import soot.MethodOrMethodContext;
import soot.SootMethod;
import soot.jimple.toolkits.annotation.purity.SootMethodFilter;
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.jimple.toolkits.callgraph.Edge;
import soot.jimple.toolkits.callgraph.ReachableMethods;
import soot.util.dot.DotGraph;

/** Create a DOT from a call graph
 */
public class CallGraphToDot
{
	DotGraph dotRepr;
	CallGraph cg;
	SootMethodFilter filter;

	/**
	 * Take a call-graph as input and construct dot graph representing it,
	 * representing only the methods not filtered by f.
	 * Methods that are not reachable from one of entry points are also
	 * excluded the generated DOT call graph.
	 * Inefficient: iterates through the whole (possibly huge) call graph,
	 * even though most methods are filtered.
	 * @param g callgraph generated by soot
	 * @param f the method filter
	 * @param headsArray the set of entrypoint methods in the callgraph
	 * 
	 */
	public CallGraphToDot(CallGraph g, SootMethodFilter f, Collection<SootMethod> heads) {
		this.cg = g;
		this.filter = f;
		Set<Map.Entry<SootMethod, SootMethod>> pairs = new HashSet<>();
		Iterator<? extends MethodOrMethodContext> headsIt = heads.iterator();
		@SuppressWarnings("unchecked")
		ReachableMethods reachable =
		new ReachableMethods(this.cg, (Iterator<MethodOrMethodContext>) headsIt);
		reachable.update();
		this.dotRepr = new DotGraph("CG");
		for(Edge e : g){
			SootMethod srcMethod = e.getSrc().method();
			SootMethod tgtMethod = e.getTgt().method();
			Map.Entry<SootMethod, SootMethod> pair =
					new AbstractMap.SimpleEntry<>(srcMethod, tgtMethod);
			if (f.want(srcMethod) && f.want(tgtMethod) && reachable.contains(srcMethod) &&
					!pairs.contains(pair)) {
				String srcName = srcMethod.toString() + "\n" + srcMethod.getBytecodeSignature();
				String tgtName = tgtMethod.toString() + "\n" + tgtMethod.getBytecodeSignature();
				this.dotRepr.drawEdge(srcName, tgtName);
				pairs.add(pair);
			}
		}
	}

	/**
	 * Put the dot graph into file f.
	 * @param f
	 */
	public void drawGraph(Path f) {
		try {
			G.v().out.println("Printing callgraph to file: " + f.resolve(""));
			OutputStream out = Files.newOutputStream(f);
			this.dotRepr.render(out, 0);
			out.close();
		} catch (IOException e) {
			System.err.println("Couldn't print call graph to " + f.resolve(""));
			e.printStackTrace();
		}
	}
}
